(* 
    This is a simple functional style OCAML implementation of
    the Extended Euclidian Algorithm. I chose OCAML because of the simplicity
    that functional languages offer in writing what can be larger
    and more complex code pieces in other languages. 
    Author: Dustin Ray
    TCSS 581
    Winter 2020
*)

print_string "\nOCAML Extended Euclidian Algorithm v1.0 \n\n";;

(*  Function resolves Bezouts Identity of the form 
        aS + bT = GCD(a, b) 
    We accept a and b as input, and recursively
    mod a by b, mapping d (the divisor) along with
    S and T to the function d, t, s - the result of
    a divided by (b multipled by t). If b is zero, we exit
    recursion and return a as GCD and 0 and 1 as coefficients S and T.*)
let rec ex_euclid a b =
	
    (* Base case *)
    if b = 0 then a, 1, 0
	
    (*  Here we say: match b and the output of a mod b with the values d, s, and t
        returned by the ex_euclid function,where given d, s, t, 
        we return d, t, (s minus a divded b multipled by t.) *)
    else match (ex_euclid b (a mod b)) with
		(d, s, t) -> d, t, s - a / b * t;;


print_string "Enter an Integer (a): \n";;
    let a = read_int();;

print_string "Enter an integer (b): \n";;
    let b = read_int();;

print_string "Results as follows:\n";;


(*  Match Statement in OCAML extracts data from patterns generated by functions.
    Here we are saying: match the values a and b with the output of the function
    ex_euclid which outputs 3 values to the "variables" d, t, and s *)
match ex_euclid a b with
    (d, t, s) -> Printf.printf "
    (GCD): %d\n 
    (Coefficient for bigger integer): %d\n 
    (Coefficient for smaller integer): %d\n\n" 
    d s t;;
